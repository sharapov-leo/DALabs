\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\begin{document}

\section*{Лабораторная работа №\,4 по курсу дискрeтного анализа: поиск образца в строке}

Выполнил студент группы 08-308 МАИ \textit{Шарапов Леонид}.

\subsection*{Условие}

\begin{enumerate}
\item Общая постановка задачи.

Необходимо реализовать один из стандартных алгоритмов поиска образцов для указанного алфавита.

\item Вариант задания. 

Реализовать поиск одного образца-маски, в котором могут встречаться «джокеры», равные любому другому элементу алфавита
, состоящий из слов не более 16 регистронезависимых латинских знаков. При работе алгоритма нужно выделить образцы, не содержащие «джокеров», найти все вхождения при помощи алгоритма Ахо-Корасик и проверить их относительное месторасположение. 

\end{enumerate}

\subsection*{Метод решения}

\begin{enumerate}
\item Разделим образец с джокерами на шаблоны без них. 
\item Найдем их стартовые позиции в образце с масками. 
\item Посчитаем количество безмасочных шаблонов. 
\item Для их хранения создадим дерево ключей (бор). Они соответствуют его листам. 
\item Далее строим связи неудач в этом дереве. 
\item Создаем массив C. 
\item Зануляем его. 
\item Выполняем поиск образцов в тексте. 
\item При их обнаружении прибавляем единицу к C[позиция начала образца в тексте + начальная позиция образца в шаблоне с джокерами - 1]
\item Просматриваем массив C, если значение какого-либо элемента равно количеству безмасочных образцов в шаблоне, то номер этого элемента является начальной позицией образца с джокерами в тексте
\end{enumerate}

Использовались книга Гасфилда и aho-corasick.narod.ru

\subsection*{Описание программы}

Весь код находится в main.cpp

Используемые типы данных
\begin{enumerate}
\item const int
\item int
\item int*
\item char
\item char*
\item \_Bool - переменная, хранящая 0 или 1
\item struct stackstate - хранит указатель на состояние автомата и следующее для него состояние
\item struct stack Occur - хранит вхождения образцов
\item struct keywordTree - хранит указатели на элемент алфавита, следующее состояние, связь неудачи и очередь вхождений
\end{enumerate}

Используемые функции
\begin{enumerate}
\item addS - добавляет в очередь элемент
\item addSO - добавляет в очередь элемент
\item deleteS - удаляет элемент очереди
\item addTree - добавляет в состояние в автомат
\item deleteTree - удаляет дерево с заданного состояния
\item g - выполняет переход в другое состояние для текущего элемента алфавита
\item add - считывает элементы алфавита со стандартного ввода, добавляет их в дерево и строит связи неудач
\item search - считывает текст со стандартного ввода и заполняет массив P для обнаружения образца с масками
\item check - обнаруживает образцы в тексте и выводит их в соответствии с заданием ЛР
\item main - выделение и очистка памяти и запуск функций работы с деревом
 
\end{enumerate}

\subsection*{Дневник отладки}

\begin{enumerate}
\item runtime test01. Причиной является потребление пустой программой на C++ 72 кб (выделение). Решением был переход на язык C
\item time limit test01.t. Исправлено бесконечное считывание символов в конструкции while(scanf), то есть добавлена проверка на равенство -1
\item runtime test03.t. Исправлена работа с джокерами: учитываются последние подряд идущие в образце джокеры.
\item wrong answer test05.t. Исправлено учитывание пустых строк текста
\item runtime error test10.t signal 11. Заменен стек на очередь в алгоритме построения связей неудач.
\item wrong answer test11.t. Исправлено добавление в непустой список элемента: новое вхождение записывалось в head, а не в tmp. Также обнаружена неполная работа алгоритма. Он не помечал вхождения подстрок в текст, которые являются подстроками других. Причиной этого является отстутствие в состояниях учета вхождений.
\end{enumerate}

\subsection*{Тест производительности}

Сложность поиска шаблона длины n с масками в количестве z в тексте длины m занимает O(n+m+z) времени

В тестировании n,m и z линейно увеличивались

Тестирование
\begin{enumerate}
\item 136 кБайт - 2,934 секунд
\item 1360 кБайт - 24,830 секунд
\item 2720 кБайт - 49,078 секунд
\end{enumerate}

По результатам тестирования сложность алгоритма соответствует заявленной

\subsection*{Выводы}

Основными сложностями программирования были изучение большого количества литературы, составление аналитических решений на бумаге, нахождение ошибки в работе алгоритма и настройка правильного вывода. В первых версиях алгоритма было слишком большое потребление памяти из-за использования языка C++, потому что пустая программа на нем потребляет 72 килобайта, поэтому чекер отказывался принимать программу, а ЛР была переписана на C. Бесконечное считывание символов было из-за отстутствия проверки равенства возвращаемого значения функцией scanf на 1 (кол-во переменных). 

\end{document}
\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\begin{document}

\section*{Лабораторная работа №\,9 по курсу дискрeтного анализа: графы}

Выполнил студент группы 08-308 МАИ \textit{Шарапов Леонид}.

\subsection*{Условие}

\begin{enumerate}
\item Общая постановка задачи.

Разработать программу на языке C или C++, реализующую алгоритм для варианта задания. Формат входных и выходных данных в нем описан. Первый тест в проверяющей системе совпадает с примером.

\item Вариант задания. 

Задан неориентированный двудольный граф, состоящий из n вершин и m ребер. Первые пронумерованы целыми числами от 1 до n. Необходимо найти максимальное паросочетание в графе алгоритмом Куна. Для обеспечения однозначности ответа списки смежности графа следует предварительно отсортировать. Граф не содержит петель и кратных ребер.

\end{enumerate}

\subsection*{Метод решения}

\begin{enumerate}
\item Считываем число вершин и ребер
\item Стандартным вводом считываем пару вершин, соединяющих ребра
\item Присваиваем элементам массива паросочетания matching значения, равные -1
\item Для каждой вершины неориентированного графа запускаем поиск в глубину. Если для текущей вершины, соответствующий ей элемент массива matching равен -1, то обнуляем массив used
\item Для отсортированного вывода максимального паросочетания выводим пару вершин, что первая меньше второй, взятой из элемента массива matching
\end{enumerate}

\subsection*{Описание программы}

Весь код записан в main.cpp

Основные типы данных
\begin{enumerate}
\item std::vector
\item std::set - чтобы не сортировать
\item int
\item char
\item bool
\item auto - для удобства
\end{enumerate}

Основные функции
\begin{enumerate}
\item main
\item dfs - поиск в глубину
\end{enumerate}

\subsection*{Дневник отладки}

\begin{enumerate}
\item time limit excedeed at test05.t - неоптимизированный алгоритм
\end{enumerate}

\subsection*{Выводы}

Основной сложностью было оптимизировать алгоритм. В различных источниках есть разные оптимизации. Чтобы получить сортированные списки смежности, можно сделать вектор множеств, в которых будут хранится узлы. Сортированный вывод можно сделать простым способом.
\end{document}